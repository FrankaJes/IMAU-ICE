clc
clear all
close all

% foldername   = 'phase2_glacial/hybrid_ZoetIverson_PMIP3ens_32km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_PMIP3ens_40km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_PMIP3ens_20km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_PMIP3ens_16km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_PMIP3ens_10km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_HadCM3_32km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_HadCM3_20km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_CCSM_32km';
% foldername   = 'phase2_glacial/hybrid_ZoetIverson_CCSM_20km';
% foldername   = 'phase2_glacial/hybrid_Coulombreg_PMIP3ens_32km';
foldername   = 'phase2_glacial/hybrid_Coulombreg_PMIP3ens_20km';

PD.filename  = '/Users/berends/Documents/Datasets/BedMachine_Greenland_v4/BedMachine_Greenland_v4_5km.nc';
time_LGM     = -17000;
time_PD      = 0;
dt_netcdf    = 100;
SL.filename  = '/Users/berends/Documents/Datasets/Sealevel/Grant_500kyr_Lambeck_deglacial_merged_sealevel_curves.dat';
filename_dst = 'deglacial_retreat_mask.nc';

%% Read LGM and present-day ice geometries, and sea-level curve
LGM.filename = [foldername '/restart_GRL.nc'];

% LGM
disp(['Reading LGM ice geometry from file ' LGM.filename '...'])
LGM.x  = ncread( LGM.filename,'x'); LGM.nx = length( LGM.x); LGM.dx = LGM.x( 2) - LGM.x( 1);
LGM.y  = ncread( LGM.filename,'y'); LGM.ny = length( LGM.y);
time   = ncread( LGM.filename,'time'); ti = find( abs( time - time_LGM) == min( abs( time - time_LGM)));
LGM.Hi = ncread( LGM.filename,'Hi',[1,1,ti],[Inf,Inf,1]);

% PD
disp(['Reading PD  ice geometry from file ' PD.filename '...'])
PD.x  = ncread( PD.filename,'x'); PD.nx = length( PD.x); PD.dx = PD.x( 2) - PD.x( 1);
PD.y  = ncread( PD.filename,'y'); PD.ny = length( PD.y);
PD.Hi = ncread( PD.filename,'Hi');

% Sea level
disp(['Reading sea-level curve from file ' SL.filename '...'])
fid = fopen( SL.filename);
temp = textscan( fid,'%f %f'); fclose( fid);
SL.time = temp{1};
SL.SL   = temp{2};

%% Map LGM geometry to PD grid (using the native IMAU-ICE downscaling approach)

disp(['Mapping LGM ice geometry from original ' num2str( LGM.dx/1e3) ' km grid to PD ' num2str( PD.dx/1e3) ' km grid...'])

LGM.Hi = map_square_to_square_cons_2nd_order_2D( LGM.nx, LGM.ny, LGM.x, LGM.y, PD.nx, PD.ny, PD.x, PD.y, LGM.Hi);

%% Calculate ice masks for both geometries

% First, calculate ice masks. Use a threshold value of 50 m, and fill any "holes" that might show up
Hi_min = 50;

LGM.icemask = double( fill_holes( LGM.Hi > Hi_min));
PD.icemask  = double( fill_holes( PD.Hi  > Hi_min));

% Make sure the margin only ever retreats
LGM.icemask( PD.icemask == 1) = 1;

%% Calculate time-dependent retreat mask
% Solve a simple diffusion equation to find a dimensionless "time of
% retreat" in between the two ice fronts

disp(['Solving diffusion equation to get approximate front retreat times...'])
scaled_time_of_retreat = solve_diffusion_equation( LGM, PD);

% Determine the times at which we want to know the ice mask
time_netcdf = (time_LGM: dt_netcdf: time_PD)';

% Get "sea-level index" at these times
SL_netcdf = interp1( SL.time, SL.SL, time_netcdf);
SL_index = 1 - (SL_netcdf - min( SL_netcdf)) / range( SL_netcdf);

% Calculate ice fraction mask timeseries
sftgif = zeros( PD.nx, PD.ny, length( time_netcdf));
ts     = zeros( size( time_netcdf));
for ti = 1: length( time_netcdf)
%   ts = max( 0.01, min( 0.99, (time_netcdf( ti) - time_PD) / (time_LGM - time_PD) ));
  ts( ti) = max( 0.01, min( 0.99, SL_index( ti) ));
  sftgif( :,:,ti) = double( scaled_time_of_retreat < ts( ti));
end

% Map ice fraction mask timeseries to the original grid

disp(['Mapping ice fraction mask timeseries from PD ' num2str( PD.dx/1e3) ' km grid to the original ' num2str( LGM.dx/1e3) ' km grid...'])

sftgif = map_square_to_square_cons_2nd_order_3D( PD.nx, PD.ny, PD.x, PD.y, LGM.nx, LGM.ny, LGM.x, LGM.y, sftgif);
sftgif = max( 0, min( 1, sftgif));

%% Set up NetCDF template
% Use the exact same format as the retreat masks generated by Heiko for PROTECT/ISMIP

% General
f.Filename         = filename_dst;
f.Name             = '/';
f.Groups           = [];
f.Format           = 'classic';
f.Attributes       = [];

% Dimensions
dim_t.Name         = 'time';
dim_t.Length       = length( time_netcdf);
dim_t.Unlimited    = true;

dim_x.Name         = 'x1';
dim_x.Length       = LGM.nx;
dim_x.Unlimited    = false;

dim_y.Name         = 'y1';
dim_y.Length       = LGM.ny;
dim_y.Unlimited    = false;

f.Dimensions(1)    = dim_x;
f.Dimensions(2)    = dim_y;
f.Dimensions(3)    = dim_t;

% x,y,t variables
var_t.Name         = 'time';
var_t.Dimensions   = dim_t;
var_t.Size         = dim_t.Length;
var_t.Datatype     = 'int32';
var_t.Attributes(1).Name  = 'long_name';
var_t.Attributes(1).Value = 'time';
var_t.Attributes(2).Name  = 'units';
var_t.Attributes(2).Value = 'years';
var_t.DeflateLevel = [];
var_t.Shuffle      = false;

var_x.Name         = 'x1';
var_x.Dimensions   = dim_x;
var_x.Size         = dim_x.Length;
var_x.Datatype     = 'double';
var_x.Attributes(1).Name  = 'long_name';
var_x.Attributes(1).Value = 'x-coordinate';
var_x.Attributes(2).Name  = 'units';
var_x.Attributes(2).Value = 'm';
var_x.DeflateLevel = [];
var_x.Shuffle      = false;

var_y = var_x;
var_y.Name         = 'y1';
var_y.Dimensions   = dim_y;
var_y.Size         = dim_y.Length;
var_y.Attributes(1).Value = 'y-coordinate';


% field variable
var.Name          = 'ice_fraction_retreat_mask';
var.Dimensions(1) = dim_x;
var.Dimensions(2) = dim_y;
var.Dimensions(3) = dim_t;
var.Size          = [dim_x.Length, dim_y.Length, dim_t.Length];
var.Datatype      = 'single';
var.Attributes(1).Name  = 'long_name';
var.Attributes(1).Value = 'ice fraction mask for retreat parameterisation';
var.Attributes(2).Name  = 'units';
var.Attributes(2).Value = '1';
var.DeflateLevel  = [];
var.Shuffle       = false;

f.Variables( 1) = var_x;
f.Variables( 2) = var_y;
f.Variables( 3) = var_t;
f.Variables( 4) = var;

%% Create and write to NetCDF file
filename = [foldername '/' filename_dst];
if exist( filename,'file')
  delete( filename)
end

ncwriteschema( filename,f);

disp(['Writing retreat mask to file ' filename '...'])

% Write x,y,time
ncwrite( filename,'x1'                       ,LGM.x      );
ncwrite( filename,'y1'                       ,LGM.y      );
ncwrite( filename,'time'                     ,time_netcdf);
ncwrite( filename,'ice_fraction_retreat_mask',sftgif     );

disp(['Done!'])

function m = fill_holes( m)

% Fill holes
m2 = imfill( m,[1,1]);
m( ~m2) = true;

% Remove islands
imid = round(size(m,1)/2);
jmid = round(size(m,2)/2);
m2 = imfill(~m,[imid,jmid]);
m( ~m2) = false;

% Also remove any "ephemeral" ice pixels (which are only connected to the
% main ice sheet diagonally)
has_changed = true;
while has_changed
  m_west  = circshift( m,[ 1, 0]);
  m_east  = circshift( m,[-1, 0]);
  m_south = circshift( m,[ 0, 1]);
  m_north = circshift( m,[ 0,-1]);
  m_prev = m;
  m( m & (~m_west) & (~m_east) & (~m_south) & (~m_north)) = false;
  if sum(sum(m_prev~=m))==0
    has_changed = false;
  end
end

end
function d_dst = map_square_to_square_cons_2nd_order_2D( nx_src, ny_src, x_src, y_src, nx_dst, ny_dst, x_dst, y_dst, d_src)
  % Map data from one square grid to another (e.g. PD ice thickness from the square grid in the input file to the model square grid)
  
  % IMAU-ICE code uses [j,i] indexing
  d_src = d_src';
  
  ddx_src              = zeros( ny_src, nx_src);
  ddy_src              = zeros( ny_src, nx_src);
  mask_dst_outside_src = zeros( ny_src, nx_src);
  d_dst                = zeros( ny_dst, nx_dst);

  % Find grid spacings
  dx_src = x_src(2) - x_src(1);
  dy_src = y_src(2) - y_src(1);
  dx_dst = x_dst(2) - x_dst(1);
  dy_dst = y_dst(2) - y_dst(1);
  Ad = dx_dst * dy_dst;

  % If the grids are equal, the solution is trivial; just copy the data
  if (dx_src == dx_dst && dy_src == dy_dst && nx_src == nx_dst && ny_src == ny_dst)
    d_dst = d_src';
    return
  end

  % Find overlaps between grids
  % dst cell [i,j] overlaps with src cells [il_src( i):iu_src( i), jl_src( j):ju_src( j)]
  
  il_src = zeros( nx_dst,1);
  iu_src = zeros( nx_dst,1);
  jl_src = zeros( ny_dst,1);
  ju_src = zeros( ny_dst,1);

  % il
  for i_dst = 1: nx_dst

    if (i_dst == 1)
      il_src( i_dst) = 1;
    else
      il_src( i_dst) = il_src( i_dst-1);
    end

    while (x_src( il_src( i_dst)) + dx_src / 2.0 < x_dst( i_dst) - dx_dst / 2.0)
      il_src( i_dst) = il_src( i_dst) + 1;
      if (il_src( i_dst) >= nx_src)
        break
      end
    end
    il_src( i_dst) = max( 1, min( nx_src, il_src( i_dst) ));

  end % for i_dst = 1, nx_dst

  il_src = il_src - 1;
  il_src = max( 1, min( nx_src, il_src));

  % iu
  for i_dst = nx_dst: -1: 1

    if (i_dst == nx_dst)
      iu_src( i_dst) = nx_src;
    else
      iu_src( i_dst) = il_src( i_dst+1);
    end

    while (x_src( iu_src( i_dst)) - dx_src / 2.0 > x_dst( i_dst) + dx_dst / 2.0)
      iu_src( i_dst) = iu_src( i_dst) - 1;
      if (iu_src( i_dst) <= 1)
        break
      end
    end
    iu_src( i_dst) = max( 1, min( nx_src, iu_src( i_dst) ));

  end % for i_dst = nx_dst, 1, -1

  iu_src = iu_src + 1;
  iu_src = max( 1, min( nx_src, iu_src));

  % jl
  for j_dst = 1: ny_dst

    if (j_dst == 1)
      jl_src( j_dst) = 1;
    else
      jl_src( j_dst) = jl_src( j_dst-1);
    end

    while (y_src( jl_src( j_dst)) + dx_src / 2.0 < y_dst( j_dst) - dx_dst / 2.0)
      jl_src( j_dst) = jl_src( j_dst) + 1;
      if (jl_src( j_dst) >= ny_src)
        break
      end
    end
    jl_src( j_dst) = max( 1, min( ny_src, jl_src( j_dst) ));

  end % for j_dst = 1, ny_dst

  jl_src = jl_src - 1;
  jl_src = max( 1, min( ny_src, jl_src));

  % ju
  for j_dst = ny_dst: -1: 1

    if (j_dst == ny_dst)
      ju_src( j_dst) = ny_src;
    else
      ju_src( j_dst) = jl_src( j_dst+1);
    end

    while (y_src( ju_src( j_dst)) - dx_src / 2.0 > y_dst( j_dst) + dx_dst / 2.0)
      ju_src( j_dst) = ju_src( j_dst) - 1;
      if (ju_src( j_dst) <= 1)
        break
      end
    end
    ju_src( j_dst) = max( 1, min( ny_src, ju_src( j_dst) ));

  end % for j_dst = ny_dst, 1, -1

  ju_src = ju_src + 1;
  ju_src = max( 1, min( ny_src, ju_src));

  % Get derivatives of d_src
  for i = 2: nx_src-1
  for j = 2: ny_src-1
    ddx_src( j,i) = (d_src( j,i+1) - d_src( j,i-1)) / (2.0 * dx_src);
    ddy_src( j,i) = (d_src( j+1,i) - d_src( j-1,i)) / (2.0 * dy_src);
  end
  end

  for i = 1: nx_dst
  for j = 1: ny_dst

    d_dst( j,i) = 0.0;
    Asum        = 0.0;

    % If this dst cell lies (partly) outside of the src grid, mark it as such;
    % in that case, use nearest-neighbour extrapolation instead of conservative remapping
    if (x_dst( i) - dx_dst/2.0 < min( x_src) - dx_src/2.0 || ...
        x_dst( i) + dx_dst/2.0 > max( x_src) + dx_src/2.0 || ...
        y_dst( j) - dx_dst/2.0 < min( y_src) - dx_src/2.0 || ...
        y_dst( j) + dx_dst/2.0 > max( y_src) + dx_src/2.0)
      mask_dst_outside_src( j,i) = 1;
      continue
    else
      mask_dst_outside_src( j,i) = 0;
    end

    for i_src = il_src( i): iu_src( i)
    for j_src = jl_src( j): ju_src( j)

      xomin = max( x_dst( i) - dx_dst/2.0, x_src( i_src) - dx_src/2.0);
      xomax = min( x_dst( i) + dx_dst/2.0, x_src( i_src) + dx_src/2.0);
      yomin = max( y_dst( j) - dy_dst/2.0, y_src( j_src) - dy_src/2.0);
      yomax = min( y_dst( j) + dy_dst/2.0, y_src( j_src) + dy_src/2.0);

      if (xomax <= xomin || yomax <= yomin); continue; end

      Asd  = (xomax - xomin) * (yomax - yomin);
      Asum = Asum + Asd;

      w0  = Asd / Ad;
      w1x = 1.0 / Ad * (line_integral_mxydx( [xomin,yomin], [xomax,yomin], 1E-9) + ...
                        line_integral_mxydx( [xomax,yomin], [xomax,yomax], 1E-9) + ...
                        line_integral_mxydx( [xomax,yomax], [xomin,yomax], 1E-9) + ...
                        line_integral_mxydx( [xomin,yomax], [xomin,yomin], 1E-9)) - w0 * x_src( i_src);
      w1y = 1.0 / Ad * (line_integral_xydy(  [xomin,yomin], [xomax,yomin], 1E-9) + ...
                        line_integral_xydy(  [xomax,yomin], [xomax,yomax], 1E-9) + ...
                        line_integral_xydy(  [xomax,yomax], [xomin,yomax], 1E-9) + ...
                        line_integral_xydy(  [xomin,yomax], [xomin,yomin], 1E-9)) - w0 * y_src( j_src);

      d_dst( j,i) = d_dst( j,i) + w0  * d_src(   j_src,i_src) + ...
                                  w1x * ddx_src( j_src,i_src) + ...
                                  w1y * ddy_src( j_src,i_src);

    end % for j_src = jr_src( j,1), jr_src( j,2)
    end % for i_src = ir_src( i,1), ir_src( i,2)

    % Safety
    if (abs( 1.0 - Asum / Ad) > 1E-4)
      error(['dst grid cell [' num2str( j) ',' num2str( i) '] couldnt be completely filled! Asum = ' num2str(Asum) ', Ad = ' num2str( Ad)])
    end

  end % for j = 1, ny_dst
  end % for i = i1, i2

  % Use nearest-neighbour extrapolation for dst cells outside of the src grid
  % =========================================================================

  % Find the range of grid cells that were mapped correctly
  igmin = 0;
  igmax = 0;
  jgmin = 0;
  jgmax = 0;

  j = round(ny_dst/2);
  for i = 1: nx_dst
    if (mask_dst_outside_src( j,i) == 0)
      igmin = i;
      break
    end
  end
  for i = nx_dst: -1: 1
    if (mask_dst_outside_src( j,i) == 0)
      igmax = i;
      break
    end
  end

  i = round(nx_dst/2);
  for j = 1: ny_dst
    if (mask_dst_outside_src( j,i) == 0)
      jgmin = j;
      break
    end
  end
  for j = ny_dst: -1: 1
    if (mask_dst_outside_src( j,i) == 0)
      jgmax = j;
      break
    end
  end

  % Corners
  % Southwest
  d_dst( 1      :jgmin-1 ,1      :igmin-1) = d_dst( jgmin,igmin);
  % Southeast
  d_dst( 1      :jgmin-1 ,igmax+1:nx_dst ) = d_dst( jgmin,igmax);
  % Northwest
  d_dst( jgmax+1:ny_dst  ,1      :igmin-1) = d_dst( jgmax,igmin);
  % Northeast
  d_dst( jgmax+1:ny_dst  ,igmax+1:nx_dst ) = d_dst( jgmax,igmax);

  % Borders
  for i = igmin: igmax
    % South
    d_dst( 1      :jgmin-1,i) = d_dst( jgmin,i);
    % North
    d_dst( jgmax+1:ny_dst ,i) = d_dst( jgmax,i);
  end
  for j = jgmin: jgmax
    % West
    d_dst( j,1      :igmin-1) = d_dst( j,igmin);
    % East
    d_dst( j,igmax+1:nx_dst ) = d_dst( j,igmax);
  end
  
  % IMAU-ICE code uses [j,i] indexing
  d_dst = d_dst';
  
  function I_pq = line_integral_xdy(   p, q, tol_dist)
    % Calculate the line integral x dy from p to q
        
    xp = p(1);
    yp = p(2);
    xq = q(1);
    yq = q(2);
    
    if (abs(yp-yq) < tol_dist)
      I_pq = 0.0;
      return
    end
    
    dx = q(1)-p(1);
    dy = q(2)-p(2);
    
    I_pq = xp*dy - yp*dx + (dx / (2.0*dy)) * (yq^2 - yp^2);
    
  end
  function I_pq = line_integral_mxydx( p, q, tol_dist)
    % Calculate the line integral -xy dx from p to q
        
    xp = p(1);
    yp = p(2);
    xq = q(1);
    yq = q(2);
    
    if (abs(xp-xq) < tol_dist)
      I_pq = 0.0;
      return
    end
    
    dx = q(1)-p(1);
    dy = q(2)-p(2);
    
    I_pq = (1.0/2.0 * (xp*dy/dx - yp) * (xq^2-xp^2)) - (1.0/3.0 * dy/dx * (xq^3-xp^3));
    
  end
  function I_pq = line_integral_xydy(  p, q, tol_dist)
    % Calculate the line integral xy dy from p to q
        
    xp = p(1);
    yp = p(2);
    xq = q(1);
    yq = q(2);
    
    if (abs(yp-yq) < tol_dist)
      I_pq = 0.0;
      return
    end
    
    dx = q(1)-p(1);
    dy = q(2)-p(2);
    
    I_pq = (1.0/2.0 * (xp - yp*dx/dy) * (yq^2-yp^2)) + (1.0/3.0 * dx/dy * (yq^3-yp^3));
    
  end

end
function d_dst = map_square_to_square_cons_2nd_order_3D( nx_src, ny_src, x_src, y_src, nx_dst, ny_dst, x_dst, y_dst, d_src)
  % Map data from one square grid to another (e.g. PD ice thickness from the square grid in the input file to the model square grid)
  
  % IMAU-ICE code uses [j,i] indexing
  d_src = permute( d_src,[3,2,1]);
  
  nz = size( d_src,1);
  
  ddx_src              = zeros( nz, ny_src, nx_src);
  ddy_src              = zeros( nz, ny_src, nx_src);
  mask_dst_outside_src = zeros(     ny_src, nx_src);
  d_dst                = zeros( nz, ny_dst, nx_dst);

  % Find grid spacings
  dx_src = x_src(2) - x_src(1);
  dy_src = y_src(2) - y_src(1);
  dx_dst = x_dst(2) - x_dst(1);
  dy_dst = y_dst(2) - y_dst(1);
  Ad = dx_dst * dy_dst;

  % If the grids are equal, the solution is trivial; just copy the data
  if (dx_src == dx_dst && dy_src == dy_dst && nx_src == nx_dst && ny_src == ny_dst)
    d_src = permute( d_src,[3,2,1]);
    return
  end

  % Find overlaps between grids
  % dst cell [i,j] overlaps with src cells [il_src( i):iu_src( i), jl_src( j):ju_src( j)]
  
  il_src = zeros( nx_dst,1);
  iu_src = zeros( nx_dst,1);
  jl_src = zeros( ny_dst,1);
  ju_src = zeros( ny_dst,1);

  % il
  for i_dst = 1: nx_dst

    if (i_dst == 1)
      il_src( i_dst) = 1;
    else
      il_src( i_dst) = il_src( i_dst-1);
    end

    while (x_src( il_src( i_dst)) + dx_src / 2.0 < x_dst( i_dst) - dx_dst / 2.0)
      il_src( i_dst) = il_src( i_dst) + 1;
      if (il_src( i_dst) >= nx_src)
        break
      end
    end
    il_src( i_dst) = max( 1, min( nx_src, il_src( i_dst) ));

  end % for i_dst = 1, nx_dst

  il_src = il_src - 1;
  il_src = max( 1, min( nx_src, il_src));

  % iu
  for i_dst = nx_dst: -1: 1

    if (i_dst == nx_dst)
      iu_src( i_dst) = nx_src;
    else
      iu_src( i_dst) = il_src( i_dst+1);
    end

    while (x_src( iu_src( i_dst)) - dx_src / 2.0 > x_dst( i_dst) + dx_dst / 2.0)
      iu_src( i_dst) = iu_src( i_dst) - 1;
      if (iu_src( i_dst) <= 1)
        break
      end
    end
    iu_src( i_dst) = max( 1, min( nx_src, iu_src( i_dst) ));

  end % for i_dst = nx_dst, 1, -1

  iu_src = iu_src + 1;
  iu_src = max( 1, min( nx_src, iu_src));

  % jl
  for j_dst = 1: ny_dst

    if (j_dst == 1)
      jl_src( j_dst) = 1;
    else
      jl_src( j_dst) = jl_src( j_dst-1);
    end

    while (y_src( jl_src( j_dst)) + dx_src / 2.0 < y_dst( j_dst) - dx_dst / 2.0)
      jl_src( j_dst) = jl_src( j_dst) + 1;
      if (jl_src( j_dst) >= ny_src)
        break
      end
    end
    jl_src( j_dst) = max( 1, min( ny_src, jl_src( j_dst) ));

  end % for j_dst = 1, ny_dst

  jl_src = jl_src - 1;
  jl_src = max( 1, min( ny_src, jl_src));

  % ju
  for j_dst = ny_dst: -1: 1

    if (j_dst == ny_dst)
      ju_src( j_dst) = ny_src;
    else
      ju_src( j_dst) = jl_src( j_dst+1);
    end

    while (y_src( ju_src( j_dst)) - dx_src / 2.0 > y_dst( j_dst) + dx_dst / 2.0)
      ju_src( j_dst) = ju_src( j_dst) - 1;
      if (ju_src( j_dst) <= 1)
        break
      end
    end
    ju_src( j_dst) = max( 1, min( ny_src, ju_src( j_dst) ));

  end % for j_dst = ny_dst, 1, -1

  ju_src = ju_src + 1;
  ju_src = max( 1, min( ny_src, ju_src));

  % Get derivatives of d_src
  for i = 2: nx_src-1
  for j = 2: ny_src-1
    ddx_src( :,j,i) = (d_src( :,j,i+1) - d_src( :,j,i-1)) / (2.0 * dx_src);
    ddy_src( :,j,i) = (d_src( :,j+1,i) - d_src( :,j-1,i)) / (2.0 * dy_src);
  end
  end

  for i = 1: nx_dst
  for j = 1: ny_dst

    d_dst( :,j,i) = 0.0;
    Asum        = 0.0;

    % If this dst cell lies (partly) outside of the src grid, mark it as such;
    % in that case, use nearest-neighbour extrapolation instead of conservative remapping
    if (x_dst( i) - dx_dst/2.0 < min( x_src) - dx_src/2.0 || ...
        x_dst( i) + dx_dst/2.0 > max( x_src) + dx_src/2.0 || ...
        y_dst( j) - dx_dst/2.0 < min( y_src) - dx_src/2.0 || ...
        y_dst( j) + dx_dst/2.0 > max( y_src) + dx_src/2.0)
      mask_dst_outside_src( j,i) = 1;
      continue
    else
      mask_dst_outside_src( j,i) = 0;
    end

    for i_src = il_src( i): iu_src( i)
    for j_src = jl_src( j): ju_src( j)

      xomin = max( x_dst( i) - dx_dst/2.0, x_src( i_src) - dx_src/2.0);
      xomax = min( x_dst( i) + dx_dst/2.0, x_src( i_src) + dx_src/2.0);
      yomin = max( y_dst( j) - dy_dst/2.0, y_src( j_src) - dy_src/2.0);
      yomax = min( y_dst( j) + dy_dst/2.0, y_src( j_src) + dy_src/2.0);

      if (xomax <= xomin || yomax <= yomin); continue; end

      Asd  = (xomax - xomin) * (yomax - yomin);
      Asum = Asum + Asd;

      w0  = Asd / Ad;
      w1x = 1.0 / Ad * (line_integral_mxydx( [xomin,yomin], [xomax,yomin], 1E-9) + ...
                        line_integral_mxydx( [xomax,yomin], [xomax,yomax], 1E-9) + ...
                        line_integral_mxydx( [xomax,yomax], [xomin,yomax], 1E-9) + ...
                        line_integral_mxydx( [xomin,yomax], [xomin,yomin], 1E-9)) - w0 * x_src( i_src);
      w1y = 1.0 / Ad * (line_integral_xydy(  [xomin,yomin], [xomax,yomin], 1E-9) + ...
                        line_integral_xydy(  [xomax,yomin], [xomax,yomax], 1E-9) + ...
                        line_integral_xydy(  [xomax,yomax], [xomin,yomax], 1E-9) + ...
                        line_integral_xydy(  [xomin,yomax], [xomin,yomin], 1E-9)) - w0 * y_src( j_src);

      d_dst( :,j,i) = d_dst( :,j,i) + w0  * d_src(   :,j_src,i_src) + ...
                                      w1x * ddx_src( :,j_src,i_src) + ...
                                      w1y * ddy_src( :,j_src,i_src);

    end % for j_src = jr_src( j,1), jr_src( j,2)
    end % for i_src = ir_src( i,1), ir_src( i,2)

    % Safety
    if (abs( 1.0 - Asum / Ad) > 1E-4)
      error(['dst grid cell [' num2str( j) ',' num2str( i) '] couldnt be completely filled! Asum = ' num2str(Asum) ', Ad = ' num2str( Ad)])
    end

  end % for j = 1, ny_dst
  end % for i = i1, i2

  % Use nearest-neighbour extrapolation for dst cells outside of the src grid
  % =========================================================================

  % Find the range of grid cells that were mapped correctly
  igmin = 0;
  igmax = 0;
  jgmin = 0;
  jgmax = 0;

  j = round(ny_dst/2);
  for i = 1: nx_dst
    if (mask_dst_outside_src( j,i) == 0)
      igmin = i;
      break
    end
  end
  for i = nx_dst: -1: 1
    if (mask_dst_outside_src( j,i) == 0)
      igmax = i;
      break
    end
  end

  i = round(nx_dst/2);
  for j = 1: ny_dst
    if (mask_dst_outside_src( j,i) == 0)
      jgmin = j;
      break
    end
  end
  for j = ny_dst: -1: 1
    if (mask_dst_outside_src( j,i) == 0)
      jgmax = j;
      break
    end
  end

  % Corners
  for k = 1: nz
    % Southwest
    d_dst( k,1      :jgmin-1 ,1      :igmin-1) = d_dst( k,jgmin,igmin);
    % Southeast
    d_dst( k,1      :jgmin-1 ,igmax+1:nx_dst ) = d_dst( k,jgmin,igmax);
    % Northwest
    d_dst( k,jgmax+1:ny_dst  ,1      :igmin-1) = d_dst( k,jgmax,igmin);
    % Northeast
    d_dst( k,jgmax+1:ny_dst  ,igmax+1:nx_dst ) = d_dst( k,jgmax,igmax);
  end

  % Borders
  for k = 1: nz
    for i = igmin: igmax
      % South
      d_dst( k,1      :jgmin-1,i) = d_dst( k,jgmin,i);
      % North
      d_dst( k,jgmax+1:ny_dst ,i) = d_dst( k,jgmax,i);
    end
    for j = jgmin: jgmax
      % West
      d_dst( k,j,1      :igmin-1) = d_dst( k,j,igmin);
      % East
      d_dst( k,j,igmax+1:nx_dst ) = d_dst( k,j,igmax);
    end
  end
  
  % IMAU-ICE code uses [j,i] indexing
  d_dst = permute(d_dst,[3,2,1]);
  
  function I_pq = line_integral_xdy(   p, q, tol_dist)
    % Calculate the line integral x dy from p to q
        
    xp = p(1);
    yp = p(2);
    xq = q(1);
    yq = q(2);
    
    if (abs(yp-yq) < tol_dist)
      I_pq = 0.0;
      return
    end
    
    dx = q(1)-p(1);
    dy = q(2)-p(2);
    
    I_pq = xp*dy - yp*dx + (dx / (2.0*dy)) * (yq^2 - yp^2);
    
  end
  function I_pq = line_integral_mxydx( p, q, tol_dist)
    % Calculate the line integral -xy dx from p to q
        
    xp = p(1);
    yp = p(2);
    xq = q(1);
    yq = q(2);
    
    if (abs(xp-xq) < tol_dist)
      I_pq = 0.0;
      return
    end
    
    dx = q(1)-p(1);
    dy = q(2)-p(2);
    
    I_pq = (1.0/2.0 * (xp*dy/dx - yp) * (xq^2-xp^2)) - (1.0/3.0 * dy/dx * (xq^3-xp^3));
    
  end
  function I_pq = line_integral_xydy(  p, q, tol_dist)
    % Calculate the line integral xy dy from p to q
        
    xp = p(1);
    yp = p(2);
    xq = q(1);
    yq = q(2);
    
    if (abs(yp-yq) < tol_dist)
      I_pq = 0.0;
      return
    end
    
    dx = q(1)-p(1);
    dy = q(2)-p(2);
    
    I_pq = (1.0/2.0 * (xp - yp*dx/dy) * (yq^2-yp^2)) + (1.0/3.0 * dx/dy * (yq^3-yp^3));
    
  end

end
function scaled_time_of_retreat = solve_diffusion_equation( LGM, PD)
% Calculate the matrix equation representing the PDE d2f/dx2 + d2f/dy2 = 0,
% with boundary conditions that f = 1 in the always-ice-free area, and f =
% 0 in the always-ice-covered area

% Masks
m_always_ice_free    = LGM.icemask == 0 & PD.icemask == 0;
m_always_ice_covered = LGM.icemask == 1 & PD.icemask == 1;
m_solve_diff_eq      = ~m_always_ice_free & ~m_always_ice_covered;

% Grid
grid = setup_grid( PD.nx, PD.ny, PD.x, PD.y);

%% Calculate big matrix

% Calculate matrix size
nrows   = grid.n;
ncols   = grid.n;
n_free  = sum(sum( m_solve_diff_eq));
n_BC    = grid.n - n_free;
nnz_max = n_BC + 5*n_free;

A.m     = nrows;
A.n     = ncols;
A.nnz   = 0;
A.ptr   = zeros( nrows+1,1) + 1;
A.ind   = zeros( nnz_max,1);
A.val   = zeros( nnz_max,1);

b       = zeros( nrows,1);

% Fill in matrix
for n = 1: grid.n
  
  % Grid indices
  i = grid.n2ij( n,1);
  j = grid.n2ij( n,2);

  A.ptr( n+1) = A.ptr( n);
  
  if m_always_ice_free( i,j)
    % Always ice-free: f = 1
    
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = n;
    A.val( A.nnz) = 1;
    b( n) = 1;
    
  elseif m_always_ice_covered( i,j)
    % Always ice-covered: f = 0
    
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = n;
    A.val( A.nnz) = 1;
    b( n) = 0;
    
  elseif m_solve_diff_eq( i,j)
    % Solve d2f/dx2 + d2f/dy2 = 0
    
    % i+1
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = grid.ij2n( i+1,j);
    A.val( A.nnz) = 1;
    
    % i-1
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = grid.ij2n( i-1,j);
    A.val( A.nnz) = 1;
    
    % j+1
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = grid.ij2n( i,j+1);
    A.val( A.nnz) = 1;
    
    % j-1
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = grid.ij2n( i,j-1);
    A.val( A.nnz) = 1;
    
    % i,j
    A.nnz = A.nnz + 1;
    A.ptr( n+1) = A.ptr( n+1) + 1;
    A.ind( A.nnz) = grid.ij2n( i,j);
    A.val( A.nnz) = -4;
    
    % Right-hand side
    b( n) = 0;
    
  else
    error('whaa!')
  end
  
end

% Convert to Matlab sparse matrix format
A = CSR_to_sparse( A);

% Solve the equation
scaled_time_of_retreat = vec2grid( grid, A\b);

  function grid = setup_grid( nx, ny, x, y)
    grid.nx = nx;
    grid.ny = ny;
    grid.n  = grid.nx * grid.ny;
    grid.x  = x;
    grid.y  = y;
    grid.dx = grid.x( 2) - grid.x( 1);

    grid.ij2n = zeros( grid.nx, grid.ny);
    grid.n2ij = zeros( grid.n , 2      );
    n = 0;
    for i = 1: grid.nx
    for j = 1: grid.ny
      n = n+1;
      grid.ij2n( i,j) = n;
      grid.n2ij( n,:) = [i,j];
    end
    end

  end
  function dv = grid2vec( grid, dg)
    dv = zeros( grid.n,1);
    for n = 1: grid.n
      dv( n) = dg( grid.n2ij( n,1), grid.n2ij( n,2));
    end
  end
  function dg = vec2grid( grid, dv)
    dg = zeros( grid.nx, grid.ny);
    for n = 1: grid.n
      dg( grid.n2ij( n,1), grid.n2ij( n,2)) = dv( n);
    end
  end
  function A = CSR_to_sparse( A_CSR)

    nnz = A_CSR.ptr(end)-1;

    Ai = zeros( nnz, 1);
    Aj = zeros( nnz, 1);
    Av = zeros( nnz, 1);

    k = 0;
    for i = 1: A_CSR.m
      for ii = A_CSR.ptr( i): A_CSR.ptr( i+1)-1
        j = A_CSR.ind( ii);
        v = A_CSR.val( ii);
        k = k+1;
        Ai( k) = i;
        Aj( k) = j;
        Av( k) = v;
      end
    end

    A = sparse( Ai,Aj,Av,A_CSR.m,A_CSR.n);

  end

end